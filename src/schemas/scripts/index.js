/**
 * Schema DAO Object
 */

const fs = require('fs');
const TsvHeader = require('./tsv-header');
const JsonSchema = require('./json-schema/');
const XmlSchema = require('./xml-schema/');
// const RelaxNg = require('./relax-ng/');
// const RdfSchema = require('./rdf-schema');
const {
  normalizeUrl,
  sanitizeUuid,
  uniqBy,
  debug,
  sortBy,
  forceArray,
  isObject,
  isEmpty,
  formatUuid,
  parseTsRange,
} = require('../utils');
const { getDb } = require('../dao/db-lifecycle');
const { hash } = require('../crypto/siphash');
const { T_SCHEMAS } = require('../dao/constants');

const COLUMNS_SCHEMAS = new PGP.helpers.ColumnSet(
  [
    'uri',
    {
      name: 'uri_hash',
      cast: 'uuid',
    },
    {
      name: 'record',
      cast: 'text',
    },
    {
      name: 'record_hash',
      cast: 'uuid',
    },
    'mediaType',

    // {
    //   name: 'time',
    //   cast: 'TSRANGE',
    //   mod: ':raw',
    // },
    // {
    //   name: 'time_sys',
    //   cast: 'TSRANGE',
    //   mod: ':raw',
    // },
  ],
  { table: T_SCHEMAS },
);


const updateSchemas = async (inputRecords, db) => {
  const records = sortBy(
    uniqBy(
      forceArray(
        inputRecords,
      ).map(
        (record) => (typeof record === 'string')
          ? {
            uri: record,
          } : record,
      ).filter(
        (schema) => (
          (!isObject(schema)) || (!isEmpty(schema.uri))
        ) && isEmpty(global.SCHEMAS_DICT[schema.uri]),
      ),
      ({ uri }) => uri,
    ),
    ({ uri }) => uri,
  );

  const result = {
    total: records.length,
    affected: 0,
    new: [],
  };
  if (records.length > 0) {
    db = db || (await getDb());
    const values = PGP.helpers.insert(records, COLUMNS_SCHEMAS);
    const res = await db.manyOrNone(`${values} ON CONFLICT(uri) DO NOTHING RETURNING uri;`);
    records.forEach((rec) => {
      global.SCHEMAS_DICT[rec.uri] = true;
    });
    result.affected = res.length;
    result.new = res.map(({ uri }) => uri);
  }
  return result;
};

const SCHEMA_TYPES = [
  JsonSchema,
  XmlSchema, // XSD
  // RdfSchema,
  // RelaxNg,
  TsvHeader,
];

const schemaTypeBymediaType = SCHEMA_TYPES.reduce((a, o) => ({
  ...a,
  [o.mediaType]: o,
}), {});


const getSchema = async (uri, db) => {
  db = db || (await getDb());
  const schemaObj = await db.oneOrNone(
    `SELECT * FROM ${T_SCHEMAS} WHERE uri = $<uri>;`,
    { uri },
  );
  if (schemaObj) {
    const schemaType = schemaTypeBymediaType[schemaObj.mediaType];

    return {
      ...schemaObj,
      validate: schemaType.compile(schemaObj.record),
    };
  } else {
    return null;
  }
};


const insertSchema = async (schemaObj, db) => {
  const values = global.PGP.helpers.values(
    [
      {
        ...schemaObj,
        record_hash: formatUuid(schemaObj.record_hash),
        uri_hash: formatUuid(schemaObj.uri_hash),
      },
    ],
    COLUMNS_SCHEMAS,
  );
  try {
    const q = `
        INSERT INTO ${T_SCHEMAS} (${COLUMNS_SCHEMAS.names})
        VALUES ${values}
        ON CONFLICT (uri) DO NOTHING
        RETURNING *;
    `;
    const dbSchemaObj = await db.oneOrNone(q);
    return schemaObj;
  } catch (e) {
    throw(e);
  }
};

const registerSchema = async (
  record,
  mediaType,
  db,
) => {
  debug(`Registering autogenerated schema without URI and media-type ${mediaType}`);
  db = db || (await getDb());
  let schemaType = schemaTypeBymediaType[mediaType];
  if (!schemaType) {
    throw Error(`No schema type for ${mediaType}`);
  }
  const record_hash = hash((typeof schemaType.normalize === 'function') ? schemaType.normalize(record) : record);
  const uri = normalizeUrl(`https://catalog.rusneb.ru/schemas/${record_hash}${schemaType.extension}`);
  let schemaObj = await getSchema(uri);

  if (!schemaObj) {
    const uri_hash = hash(uri);
    schemaObj = await insertSchema(
      {
        uri,
        uri_hash,
        record,
        record_hash,
        mediaType,
      },
      db,
    );
  }
  return {
    ...schemaObj,
    validate: schemaType.compile(schemaObj.record),
  };
};

const registerSchemaUri = async (
  uri,
  localPath,
  mediaType,
  db,
) => {
  debug(`Registering schema URI: ${uri} media-type ${mediaType} using local content path ${localPath}`);
  db = db || (await getDb());
  let schemaType = schemaTypeBymediaType[mediaType];
  if (!schemaType) {
    throw Error(`No schema type for ${mediaType}`);
  }
  const record = fs.readFileSync(localPath, 'utf-8');
  let schemaObj = await getSchema(uri);

  if (!schemaObj) {
    schemaObj = await insertSchema(
      {
        uri,
        uri_hash: hash(normalizeUrl(uri)),
        record,
        record_hash: hash(schemaType.normalize(record)),
        mediaType,
      },
      db,
    );
  }
  return {
    ...schemaObj,
    validate: schemaType.compile(schemaObj.record),
  };
};

module.exports = {
  updateSchemas,
  registerSchema,
  registerSchemaUri,
  getSchema,
  COLUMNS_SCHEMAS,
};
